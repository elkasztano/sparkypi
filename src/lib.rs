use std::{thread, time};
use rppal::gpio::OutputPin;

pub mod constants;

pub struct Transmission {
    pub sequence: String,
    pub pulse_length: u16,
    pub repeats: u8,
}

impl Transmission {
// the sequence is generated by looping through the characters of a string slice
// if the character is '1' a binary one will be transmitted, or a binary zero if the character is
// '0', respectively
// all other characters will result in a sync bit
    pub fn send_to(&self, rc: &mut OutputPin) {
        for _ in 0..self.repeats {
            for c in self.sequence.chars() {
                if c == '1' {
                    send_bit(rc, true, self.pulse_length);
                } else if c == '0' {
                    send_bit(rc, false, self.pulse_length);
                } else {
                    send_sync_bit(rc, self.pulse_length);
                }
            }
        }
    }
}

// send one single bit
// long pulse and short pause results in a binary one
// short pulse and long pause results in a binary zero
// the relation between short and long period is 1:3
// this must possibly be adapted according to the used protocol
fn send_bit(rc: &mut OutputPin, bit: bool, pulse_length: u16) {
    if bit {
        rc.set_high();
        thread::sleep(time::Duration::from_micros(pulse_length as u64 * 3));
        rc.set_low();
        thread::sleep(time::Duration::from_micros(pulse_length as u64));
    } else {
        rc.set_high();
        thread::sleep(time::Duration::from_micros(pulse_length as u64));
        rc.set_low();
        thread::sleep(time::Duration::from_micros(pulse_length as u64 * 3));
    }
}

// a so called sync bit must be transmitted before the actual data
// the sync bit consists of one short pulse and a following pause that is 31 times as long
fn send_sync_bit(rc: &mut OutputPin, pulse_length: u16) {
    rc.set_high();
    thread::sleep(time::Duration::from_micros(pulse_length as u64));
    rc.set_low();
    thread::sleep(time::Duration::from_micros(pulse_length as u64 * 31));
}
