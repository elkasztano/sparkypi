use std::{thread, time};
use rppal::gpio::OutputPin;

pub mod constants;

pub struct Transmission {
    pub sequence: String,
    pub pulse_length: u64,
    pub repeats: usize,
}

// send one single bit
// long pulse and short pause results in a binary one
// short pulse and long pause results in a binary zero
// the relation between short and long period is 1:3
// this must possibly be adapted according to the used protocol
fn send_bit(rc: &mut OutputPin, bit: bool, pulse_length: u64) {
    if bit {
        rc.set_high();
        thread::sleep(time::Duration::from_micros(pulse_length * 3));
        rc.set_low();
        thread::sleep(time::Duration::from_micros(pulse_length));
    } else {
        rc.set_high();
        thread::sleep(time::Duration::from_micros(pulse_length));
        rc.set_low();
        thread::sleep(time::Duration::from_micros(pulse_length * 3));
    }
}

// a so called sync bit must be transmitted before the actual data
// the sync bit consists of one short pulse and a following pause that is 31 times as long
fn send_sync_bit(rc: &mut OutputPin, pulse_length: u64) {
    rc.set_high();
    thread::sleep(time::Duration::from_micros(pulse_length));
    rc.set_low();
    thread::sleep(time::Duration::from_micros(pulse_length * 31));
}

// the final sequence is generated by looping through the characters of a string slice
// if the character is '1' a binary one will be transmitted, or a binary zero if the character is
// '0', respectively
// all other characters will result in a sync bit
pub fn send_sequence(rc: &mut OutputPin, tm: Transmission) {
    for _ in 0..tm.repeats {
        for c in tm.sequence.chars() {
            if c == '1' {
                send_bit(rc, true, tm.pulse_length);
            } else if c == '0' {
                send_bit(rc, false, tm.pulse_length);
            } else {
                send_sync_bit(rc, tm.pulse_length);
            }
        }
    }
}


