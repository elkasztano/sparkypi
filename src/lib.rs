use std::{thread, time};
use rppal::gpio::OutputPin;

pub mod constants;

#[derive(Debug,Default)]
pub struct Transmission {
    pub sequence: String,
    pub pulse_length: u16,
    pub repeats: u8,
    pub protocol: ProtocolProperties,
}

#[derive(Debug,Default)]
pub struct ProtocolProperties {
    pub short: u8,
    pub long: u8,
    pub sync_bit: u8,
    pub sync_gap: u8,
}

impl ProtocolProperties {
    pub fn new() -> Self {
        Default::default()
    }
}

// 'protocol1' - tested
pub const P1: ProtocolProperties = ProtocolProperties {
    short: 1,
    long: 3,
    sync_bit: 1,
    sync_gap: 31,
};

// 'protocol2' - untested
pub const P2: ProtocolProperties = ProtocolProperties {
    short: 1,
    long: 2,
    sync_bit: 1,
    sync_gap: 10,
};

// slightly different to 'protocol2' - tested
pub const XEN: ProtocolProperties = ProtocolProperties {
    short: 1,
    long: 2,
    sync_bit: 1,
    sync_gap: 11,
};

impl Transmission {

    pub fn new() -> Self {
        Default::default()
    }

// the sequence is generated by looping through the characters of a string slice
// if the character is '1' a binary one will be transmitted, or a binary zero if the character is
// '0', respectively
// all other characters will result in a sync bit
    pub fn send_to(&self, rc: &mut OutputPin) {
        
        for _ in 0..self.repeats {

            for c in self.sequence.chars() {

                if c == '1' {
                    send_bit(rc, true, self.pulse_length, self.protocol.long, self.protocol.short);
                } else if c == '0' {
                    send_bit(rc, false, self.pulse_length, self.protocol.long, self.protocol.short);
                } else {
                    send_sync_bit(rc, self.pulse_length, self.protocol.sync_gap, self.protocol.sync_bit);
                }

            }
        }
    }
}

// send one single bit
// long pulse and short pause results in a binary one
// short pulse and long pause results in a binary zero
fn send_bit(rc: &mut OutputPin, bit: bool, pulse_length: u16, factor1: u8, factor2: u8) {
    if bit {
        rc.set_high();
        thread::sleep(time::Duration::from_micros(pulse_length as u64 * factor1 as u64));
        rc.set_low();
        thread::sleep(time::Duration::from_micros(pulse_length as u64 * factor2 as u64));
    } else {
        rc.set_high();
        thread::sleep(time::Duration::from_micros(pulse_length as u64 * factor2 as u64));
        rc.set_low();
        thread::sleep(time::Duration::from_micros(pulse_length as u64 * factor1 as u64));
    }
}

// a so called sync bit must be transmitted before the actual data
fn send_sync_bit(rc: &mut OutputPin, pulse_length: u16, factor1: u8, factor2: u8) {
    rc.set_high();
    thread::sleep(time::Duration::from_micros(pulse_length as u64 * factor2 as u64));
    rc.set_low();
    thread::sleep(time::Duration::from_micros(pulse_length as u64 * factor1 as u64));
}
